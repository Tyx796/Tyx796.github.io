<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Thread一、认识线程（thread）1.线程（process）与进程（Thread）​	进程： ​	进程是操作系统中运行的一个独立程序实例。每个进程都有自己独立的一块内存空间，由操作系统来分配给它们资源。在java中JVM本身就是一个进程，它从main方法开始执行，运行main的那个线程，在里面还可以创建其他线程来执行。 ​	线程： ​	线程运行在进程的内部，相比较进程成本更低。 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="Java：多线程">
<meta property="og:url" content="http://example.com/2025/10/16/Treads/index.html">
<meta property="og:site_name" content="tyx&#39;s blog">
<meta property="og:description" content="Thread一、认识线程（thread）1.线程（process）与进程（Thread）​	进程： ​	进程是操作系统中运行的一个独立程序实例。每个进程都有自己独立的一块内存空间，由操作系统来分配给它们资源。在java中JVM本身就是一个进程，它从main方法开始执行，运行main的那个线程，在里面还可以创建其他线程来执行。 ​	线程： ​	线程运行在进程的内部，相比较进程成本更低。 ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/10/16/images/Treads/3b19d1c2-9254-4b9f-b306-6e3dbae10033.png">
<meta property="og:image" content="http://example.com/2025/10/16/images/Treads/image-20251012171914365.png">
<meta property="article:published_time" content="2025-10-16T07:56:33.395Z">
<meta property="article:modified_time" content="2025-10-16T11:43:28.587Z">
<meta property="article:author" content="tyx796">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/10/16/images/Treads/3b19d1c2-9254-4b9f-b306-6e3dbae10033.png">

<link rel="canonical" href="http://example.com/2025/10/16/Treads/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java：多线程 | tyx's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">tyx's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/16/Treads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tyx796">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tyx's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java：多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-16 15:56:33 / 修改时间：19:43:28" itemprop="dateCreated datePublished" datetime="2025-10-16T15:56:33+08:00">2025-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="一、认识线程（thread）"><a href="#一、认识线程（thread）" class="headerlink" title="一、认识线程（thread）"></a>一、认识线程（thread）</h2><h3 id="1-线程（process）与进程（Thread）"><a href="#1-线程（process）与进程（Thread）" class="headerlink" title="1.线程（process）与进程（Thread）"></a>1.线程（process）与进程（Thread）</h3><p>​	<strong>进程</strong>：</p>
<p>​	进程是操作系统中运行的一个独立程序实例。每个进程都有自己独立的一块内存空间，由操作系统来分配给它们资源。在java中JVM本身就是一个进程，它从main方法开始执行，运行main的那个线程，在里面还可以创建其他线程来执行。</p>
<p>​	<strong>线程</strong>：</p>
<p>​	线程运行在进程的内部，相比较进程成本更低。</p>
<p>​	</p>
<img src="../images/Treads/3b19d1c2-9254-4b9f-b306-6e3dbae10033.png" alt="image-20251009232648502" width="600" />




<p>​	关于线程：</p>
<ul>
<li><p>每个线程有自己的调用栈（call stack）：用来存储方法调用、局部变量等。</p>
</li>
<li><p>线程共享进程的数据：同一进程内的线程能访问相同的堆内存数据（这也是线程安全问题的来源）。</p>
</li>
<li><p>每个线程也有自己的本地缓存（memory cache）：</p>
<ul>
<li>当线程读取共享数据时，它可能会把数据复制到自己的缓存里。</li>
<li>如果数据更新了，而线程还在用旧缓存，就会出现可见性问题。</li>
</ul>
</li>
</ul>
<h3 id="2-在并发执行过程中的关键概念"><a href="#2-在并发执行过程中的关键概念" class="headerlink" title="2.在并发执行过程中的关键概念"></a>2.在并发执行过程中的关键概念</h3><ul>
<li><p><strong>1.Atomicity（原子性）</strong></p>
<p><strong>定义</strong>：一个操作是原子的，意味着它不可被中断，要么全部执行完成，要么完全不执行。</p>
<p><strong>例子</strong>：<code>a = 5</code> 是原子操作，<code>a++</code> 不是</p>
</li>
<li><p><strong>2.Visibility（可见性）</strong></p>
<p><strong>定义</strong>：一个线程对变量的修改，是否能被其他线程立刻看到。</p>
<p><strong>问题来源</strong>：线程有自己的工作内存（缓存），变量更新可能先存在缓存里，而不是直接写入主内存。可能会导致条件竞争。</p>
</li>
<li><p><strong>3.Order of execution（执行顺序）</strong></p>
<p>在单线程程序里，代码会按照书写的顺序逐行执行。但是在并发编程中执行顺序不再保证，多线程可能交替运行，导致结果和预期不一样。</p>
</li>
<li><p><strong>4. Critical code（临界区代码）</strong></p>
<p><strong>定义</strong>：一段<strong>只能由一个线程独占执行的代码</strong>，否则可能造成数据不一致或冲突。</p>
<p><strong>例子</strong>：银行转账操作（扣钱 + 加钱）必须是临界区代码，否则会出错。</p>
</li>
</ul>
<h3 id="3-Thread类"><a href="#3-Thread类" class="headerlink" title="3.Thread类"></a>3.Thread类</h3><p>在Thread类中我们需要将要执行的代码写在<code>run()</code>方法里面线程在启动之后将会自动地执行这个方法，如果我们需要执行<code>run()</code>方法里面的代码我们需要使用<code>start()</code>方法来启动线程，它会调用JVM的底层机制来创建新的线程进而执行<code>run()</code>的代码。</p>
<p>同时Thread类还负责线程的启动和调度（通过 JVM + 操作系统）、提供一些方法（<code>join()</code>、<code>sleep()</code>、<code>interrupt()</code> 等）来控制线程行为。</p>
<p>创建线程有两种方式：</p>
<ul>
<li><p>使用Runnable接口，<code>implements Runnable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable 方式运行线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>继承 <code>Thread</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;继承 Thread 类运行线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>推荐使用Runnable接口，因为 Java 不支持多继承，这样做会限制扩展性。</p>
<blockquote>
<p>Using the Runnable interface allows a  subclass of Thread to be used if required.</p>
</blockquote>
<h2 id="二、控制线程"><a href="#二、控制线程" class="headerlink" title="二、控制线程"></a>二、控制线程</h2><h3 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1.sleep()"></a>1.<code>sleep()</code></h3><p><code>Thread.sleep(long millis)</code> 会让<strong>当前正在执行的线程</strong>暂停指定毫秒数，进入 <em>TIMED_WAITING</em>，到点后回到可运行队列；这样能把 CPU 让给别的线程，同时<code>sleep()</code>是一个静态方法。</p>
<p>需要注意的是：</p>
<ul>
<li><p><code>sleep()</code><strong>只能让“当前线程”睡</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepOnlyCurrentThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里调用 sleep，睡的是“当前线程”，也就是 run() 里的线程</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SleepOnlyCurrentThread</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepOnlyCurrentThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main 线程准备睡眠...&quot;</span>);</span><br><span class="line">            t1.sleep(<span class="number">3000</span>);<span class="comment">// 实际上是主线程调用 sleep</span></span><br><span class="line">            System.out.println(<span class="string">&quot;main 线程醒来了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行之后会发现<code>t1.sleep(3000);</code>这段代码并不会让该线程睡眠3秒而是直接让<code>main()</code>的线程睡眠三秒，由此可见<code>sleep()</code>方法只能让该线程睡眠</p>
</li>
<li><p><strong>必须要处理<code>InterruptedException</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备睡眠...&quot;</span>);</span><br><span class="line">        <span class="comment">//Thread.sleep(1000); // 编译错误：必须处理 InterruptedException</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正确做法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 恢复中断标志，优雅退出</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程在睡眠时被中断，安全退出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;醒来了！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SleepDemo</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sd);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sd);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码编译过程中会出现<code>Unhandled exception type InterruptedException</code>的报错，因此要使用<code>sleep()</code>时应该使用try&#x2F;catch来捕获异常</p>
</li>
</ul>
<h3 id="2-Yield"><a href="#2-Yield" class="headerlink" title="2.Yield()"></a>2.<code>Yield()</code></h3><p><code>Thread.yield()</code> 是一个 <strong>静态方法</strong>。它的作用是：<strong>提示调度器</strong>“当前线程愿意让出 CPU”，让同等优先级的其他线程有机会运行。但是<strong>不保证一定会切换</strong>，调度器可能忽略这个提示。</p>
<h3 id="3-interrupt"><a href="#3-interrupt" class="headerlink" title="3.interrupt()"></a>3.<code>interrupt()</code></h3><p>在Java中<code>interrupt()</code>用来通知线程该结束当前的工作了，注意：<strong>只是通知而不是强制</strong>。</p>
<p>一个线程可以对其他的线程执行<code>interrupt()</code>操作，执行之后线程对象的中断标志变量（一个布尔类型的变量）将会变为True。此时可以通过<code>t.isInterrupted()</code>来检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 死循环，不检查中断标记</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行: &quot;</span> + i++);</span><br><span class="line">            <span class="comment">// 模拟耗时，但不用 sleep</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10_0000</span>) &#123;</span><br><span class="line">                i = <span class="number">0</span>; <span class="comment">// 防止数字过大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptNoStopDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BusyTask</span>(), <span class="string">&quot;工作线程&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 主线程等一秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：尝试中断工作线程&quot;</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 发出中断信号</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：中断标记是否为真？ &quot;</span> + t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该程序即便在“主线程：中断标记是否为真？”出现之后也会一直运行，<code>t.isInterrupted()</code>会返回True。</p>
<p>当一个线程处于 sleep &#x2F; wait 状态时，如果这个时候对这个线程执行<code>interrupt()</code>，并把中断标志设置为True，这时候由于线程正在sleep &#x2F; wait，于是线程会立即抛出<code>InterruptedException</code>异常,抛出异常的同时JVM将中断标志立马设置为False</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个任务类，实现 Runnable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程开始睡眠...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); <span class="comment">// 睡眠 5 秒</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正常醒来&quot;</span>); <span class="comment">// 如果没被中断会执行这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程在睡眠时被中断！&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;catch 中检查中断标志 = &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepInterruptDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SleepTask</span>()); <span class="comment">// 创建线程并传入任务</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 主线程休眠 2 秒，确保子线程进入睡眠</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：准备中断子线程&quot;</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>interrupt()</code>的意义：</p>
<p>如果我们在等待某个线程完成，但它进入了 <code>sleep()</code> 或 <code>wait()</code> 状态（睡眠或等待），那就会无限卡住。这时候我们可以调用 <code>interrupt()</code>，强制唤醒它，这样程序才能继续往下走。</p>
<p>线程被阻塞的原因：</p>
<ul>
<li><code>sleep()</code> 或 <code>wait()</code> 状态</li>
<li>锁竞争一个进程拿到了锁另一个进程就必修等待</li>
<li>I&#x2F;O等待</li>
</ul>
<h3 id="4-线程之间的协调：join"><a href="#4-线程之间的协调：join" class="headerlink" title="4.线程之间的协调：join()"></a>4.线程之间的协调：<code>join()</code></h3><p><strong>为什么需要线程之间的协调？</strong></p>
<p>因为线程之间的执行顺序是不固定的，这样会导致代码执行过程中出错。假设你有 5 个线程分别做计算，最后要把结果相加，如果主线程不等它们完成就去加，会得到错误的结果。因此我们有的时候需要规范线程之间的执行顺序，等待其他线程执行完之后再执行当前的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 TaskA: &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成 TaskA&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个任务，需要等待 TaskA 完成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread threadToWait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskB</span><span class="params">(Thread threadToWait)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadToWait = threadToWait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 等待 &quot;</span> + threadToWait.getName() + <span class="string">&quot; 完成...&quot;</span>);</span><br><span class="line">            threadToWait.join(); <span class="comment">// 等待 TaskA 的线程执行完</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行 TaskB&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行 TaskB: &quot;</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成 TaskB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoThreadsJoinDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TaskA</span>(), <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TaskB</span>(t1), <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个例子中线程t2会等待线程t1执行结束之后才会执行。</p>
<p>这时候读者可能会存在疑问如果把<code>t1.start();</code>注释掉，然后执行程序会怎么样？</p>
<p>答案是t2仍然会被执行不会因为t1没被执行而陷入一直等待的情况，原因是 <code>join()</code> 的语义是：等线程终止，如果它从来没启动过，那相当于立即终止。在java里面对于每一个线程对象，都会有它的状态信息，<code>join()</code>会不断地检查等待的线程的状态来判断是否让该线程执行，对于还没有被执行的线程，它的状态时New，<code>join()</code>在检查之后会返回False来告诉线程不用进行等待。</p>
<h2 id="三、中断和终止线程"><a href="#三、中断和终止线程" class="headerlink" title="三、中断和终止线程"></a>三、中断和终止线程</h2><p>关于<code>interrupt()</code>之前已经做过介绍因此这里就不在赘述。</p>
<h3 id="1-interrupted"><a href="#1-interrupted" class="headerlink" title="1.interrupted()"></a>1.<code>interrupted()</code></h3><p><code>public static boolean interrupted()</code></p>
<ul>
<li><p><strong>静态方法</strong>，属于 <code>Thread</code> 类。</p>
</li>
<li><p>用来检查 <strong>当前线程</strong> 的中断状态（interrupt flag）。</p>
</li>
<li><p>会清除中断标志，调用一次之后会将原来标志位的True改为False。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 演示：Thread.interrupted() 会清除中断标志</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：初次调用 Thread.interrupted() = &quot;</span> + Thread.interrupted()); <span class="comment">// 通常为 false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：进入 sleep...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); <span class="comment">// 等待主线程来中断</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：正常醒来（未被中断）&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 子线程在 sleep 中被 interrupt 会抛异常，并且 JVM 已把中断标志清零</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：sleep 被中断，catch 中 isInterrupted() = &quot;</span> + Thread.currentThread().isInterrupted()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了演示 “Thread.interrupted() 会清除标志”，我们先把标志重新设回 true</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：手动设回中断标志后 isInterrupted() = &quot;</span> + Thread.currentThread().isInterrupted()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在用 Thread.interrupted() 读取并清除</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：调用 Thread.interrupted() = &quot;</span> + Thread.interrupted()); <span class="comment">// true，并清除标志</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程：再次调用 Thread.interrupted() = &quot;</span> + Thread.interrupted()); <span class="comment">// false（已被清除）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptedCheckDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ChildTask</span>(), <span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让子线程先进入 sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：中断子线程&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="../images/Treads/image-20251012171914365.png" alt="image-20251012171914365" width="1000" />

<p>从演示的结果可以看出来<code>interrupted()</code>会将原来标志位的True改为False。</p>
<p>因此在使用<code>interrupted()</code>时特别是<code>interrupted()</code>作为循环的判断条件的时，要记得把中断标志再设置会True。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始工作...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环执行任务，直到检测到中断信号</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行耗时任务...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 捕获到 InterruptedException！&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 恢复中断标志（因为sleep抛出异常时会自动清除）</span></span><br><span class="line">                <span class="comment">//Thread.currentThread().interrupt();</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已恢复中断标志！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 检测到中断信号，安全退出。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestoreInterruptExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WorkerThread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerThread</span>();</span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待一会儿再发出中断信号</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：准备中断工作线程...&quot;</span>);</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里代码中的<code>Thread.currentThread().interrupt();</code>被注释掉了因为中断标志被重新变到了False，程序会陷入到死循环当中。</p>
<h3 id="2-isInterrupted"><a href="#2-isInterrupted" class="headerlink" title="2.isInterrupted()"></a>2.<code>isInterrupted()</code></h3><p><code>public boolean isInterrupted()</code></p>
<ul>
<li><strong>实例方法</strong>，作用在某个具体的 <code>Thread</code> 对象上。可以用来检查别的线程的中断状态。</li>
<li>调用之后线程的中断标志不会被改变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsInterruptedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程检测到中断标志，退出&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：调用 t.interrupt()&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：再次检查 t.isInterrupted() = &quot;</span> + t.isInterrupted()); <span class="comment">// true，标志没有被清除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-isAlive"><a href="#3-isAlive" class="headerlink" title="3.isAlive()"></a>3.<code>isAlive()</code></h3><p><code>public boolean isAlive()</code></p>
<ul>
<li>如果线程已启动并且仍在运行或者处于 <code>waiting</code>、<code>sleeping</code> 或 <code>blocked</code> 状态中，<code>isAlive()</code> 返回 <code>true</code>。</li>
<li>如果线程已经 <strong>终止</strong>（即 <code>run()</code> 方法执行完毕或者线程被中止），<code>isAlive()</code> 返回 <code>false</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟线程工作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程工作完成！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadAliveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印线程是否存活</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程 t1 启动前 isAlive() = &quot;</span> + t1.isAlive());  <span class="comment">// false, 因为线程还没有启动</span></span><br><span class="line">        </span><br><span class="line">        t1.start();  <span class="comment">// 启动线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程 t1 启动后 isAlive() = &quot;</span> + t1.isAlive());  <span class="comment">// true, 因为线程正在运行</span></span><br><span class="line">        </span><br><span class="line">        t1.join();  <span class="comment">// 主线程等待 t1 完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程 t1 完成后 isAlive() = &quot;</span> + t1.isAlive());  <span class="comment">// false, 因为线程已经终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-终止线程的方法"><a href="#4-终止线程的方法" class="headerlink" title="4.终止线程的方法"></a>4.终止线程的方法</h3><ul>
<li><p>线程自然完成工作并退出<code>run()</code>方法，正常地结束其生命周期，释放相关资源。</p>
</li>
<li><p>对于守护线程（daemon thread），当所有非守护线程执行结束之后，所有的daemon thread都会被强制终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DaemonExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">userThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(), <span class="string">&quot;用户线程&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">BackgroundTask</span>(), <span class="string">&quot;守护线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将后台线程设置为守护线程</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        userThread.start();</span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个普通的用户线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始工作。&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行第 &quot;</span> + i + <span class="string">&quot; 步&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 工作完成！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟后台运行的守护线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BackgroundTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在后台运行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从示例代码中的运行结果可以看出守护进程在用户进程和主进程结束之后就会自动地结束。</p>
</li>
<li><p>线程在执行工作中收到中断信号，它会根据目前的情况，可能决定不再继续工作。</p>
</li>
</ul>
<h2 id="四、多线程中的数据安全"><a href="#四、多线程中的数据安全" class="headerlink" title="四、多线程中的数据安全"></a>四、多线程中的数据安全</h2><h3 id="1-volatile关键字"><a href="#1-volatile关键字" class="headerlink" title="1.volatile关键字"></a>1.<code>volatile</code>关键字</h3><p>正如前面所说线程有自己的本地缓存，当线程读取共享数据时，它可能会把数据复制到自己的缓存里，因此就有可能出现一个线程掌握新的数据信息但是其他线程掌握的是旧的数据信息的情况。</p>
<p>为了避免这样的情况<code>volatile</code>帮助我们做到了</p>
<ul>
<li><p><strong>保证可见性</strong>：所有读写操作都直接从主内存中获取或写入，而不会进入到线程本地缓存当中，并且每一次只能被一个线程加载和储存。</p>
</li>
<li><p><strong>禁止指令重排优化</strong>：确保代码执行的顺序和我们写的逻辑一致。</p>
</li>
<li><p>需要注意的是<code>volatile</code>并不能保证原子性对于<code>i++</code> 这样的操作依然不能保证其的安全性，他只适合一些简单的读写操作。</p>
</li>
</ul>
<blockquote>
<p>！对于<code>volatile int[] arr;</code>只有数组的引用是volatile的，而对于数组内部的元素 <code>arr[5]</code>则并不是。</p>
<p>！对于申明为<code>final</code>的字段<code>volatile</code>是没有必要的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 没有 volatile</span></span><br><span class="line">    <span class="comment">// private volatile boolean running = true; // 有 volatile</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 空循环，模拟工作</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束运行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopTask</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 主线程等一会儿</span></span><br><span class="line">        System.out.println(<span class="string">&quot;准备停止线程...&quot;</span>);</span><br><span class="line">        t.stopTask(); <span class="comment">// 尝试停止线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已经停止线程...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于示例代码的的2、3两行，当<code>running</code>不是<code>volatile</code>时，程序会卡在子线程的循环里出不来，当给其加上关键字<code>volatile</code>时程序才能顺利结束。</p>
<p>接下来的代码将演示<code>volatile</code>并不能保证原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                count++;  <span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后的执行结果<code>counter</code>的值可能小于2000（也可能是等于2000的，此时将循环的次数调大，则预期的竞争便会很容易出现）</p>
<h3 id="2-锁与synchronized"><a href="#2-锁与synchronized" class="headerlink" title="2.锁与synchronized"></a>2.锁与<code>synchronized</code></h3><p><strong>临界区（Critical sections）</strong></p>
<p>​	在程序中，从不同的并发线程访问相同数据的代码段被称为临界区，在java中我们使用锁与<code>synchronized</code>来控制临界区，来保证一个同步代码块在任何给定时间只能被单个线程访问</p>
<p><strong>锁</strong></p>
<p>​	在java中锁被分为内部锁和外部锁，在这里我们只讨论内部锁。锁应用于特定的代码段，如果一段代码被锁住那么其他线程则不能执行这段代码。通常我们使用<code>synchronized</code>关键字来修饰一段代码块以给其加上内部锁。</p>
<p>​	对于<code>synchronized</code>，可以用其修饰整个方法体，也可以修饰方法体下面的某段关键代码(但是必修提供内在锁的对象），以此提高并发性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰一段代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰整个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="keyword">synchronized</span> <span class="title function_">getNextValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	但是需要注意的是<code>synchronized</code> 方法本质上就是给 <code>this</code> 对象加锁，上述这两个修饰方法是等效的。同时，同一个对象上的锁是共享的，因此如果一个类有多个 <code>synchronized</code> 方法，在同一时刻，<strong>只能有一个线程执行这两个方法中的任意一个</strong>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果一个线程在执行 <code>deposit()</code>，另一个线程想执行 <code>withdraw()</code>，它必须等 <code>deposit()</code> 里的锁释放。这样就可以保证 <code>balance</code> 数据的安全性。</p>
<p>​	**对于 <code>static synchronized</code>**锁的对象就是类对象，这个类的所有实例都共享同一把锁。</p>
<p>​	因此，如果要避免上述条件竞争的情况出现，给其代码块加上锁便可以避免。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里也可以用synchronized来修饰类对象这样所有的实例共用一把锁也能避免上述条件竞争的发生。</p>
</blockquote>
<h3 id="3-synchronized"><a href="#3-synchronized" class="headerlink" title="3. synchronized"></a>3. <code>synchronized</code></h3><ul>
<li><p>锁只会作用在 <code>synchronized</code> 方法或代码块上，没被 <code>synchronized</code> 方法或代码块不会被锁限制。</p>
</li>
<li><p>如果当前线程已经拿到了这个对象的锁，那么它可以在一个 <code>synchronized</code> 方法中调用另外一个 <code>synchronized</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    m2(); <span class="comment">// m2 不是同步方法，也能调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因是对于锁而言，每个锁都有一个 <strong>计数器</strong>，当线程进入 <code>synchronized</code> 方法时+1，退出时-1，只有在计数器为0的时候它才会让另外一个线程进入。</p>
</li>
<li><p><code>synchronized</code>不会自动继承，如果一个父类的方法是 <code>synchronized</code> 的，子类override这个方法时，不会自动继承 <code>synchronized</code> 修饰。必须在子类里再次显式写上 <code>synchronized</code>，否则就是非同步方法。</p>
</li>
<li><p>注意 <code>synchronized</code> 必须加在 <strong>对象引用</strong> 上，不能加在基本类型（如 <code>int</code>、<code>double</code>）上。</p>
</li>
</ul>
<h2 id="五、监视器（Monitor）"><a href="#五、监视器（Monitor）" class="headerlink" title="五、监视器（Monitor）"></a>五、监视器（Monitor）</h2><p>​	根据之前所讲的<code>synchronized</code> 做到了同一时刻只允许一个线程进入某段被保护的代码，但是很多情况下还需要线程之间的协作，比如一个线程负责往缓冲区写入数据，一个线程负责从缓冲区读出数据，这时候当缓冲区满了，线程就不能写入，缓冲区空了，线程也不能执行读取操作。</p>
<h3 id="1-notify-和wait"><a href="#1-notify-和wait" class="headerlink" title="1. notify()和wait()"></a>1. <code>notify()</code>和<code>wait()</code></h3><p>Monitor通过使用<code>synchronized</code> 、 <code>notify()</code>、 <code>wait()</code>来实现进程之间的协作，其中：</p>
<p> <code>wait()</code>：让线程暂时挂起，释放当前持有的锁，线程进入等待集合（Wait Set），进入阻塞状态，等待被 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</p>
<p> <code>notify()</code>：唤醒等待集合（Wait Set）里的一个线程，被唤醒的线程会从 Wait Set 移动到 Entry Set，等待重新竞争锁，拿到锁之后它才会从 <code>wait()</code>里面返回，也就是从<code>wait()</code>方法里面退出。</p>
<p><code>notifyAll()</code>:唤醒所有wait set 里的线程，大家都去竞争锁，只有一个能真正执行，其余的还会继续等待。</p>
<blockquote>
<p>Java 中每个对象都可以作为 Monitor，因为 <code>synchronized</code>、<code>wait()</code>、<code>notify()</code> 都是依赖对象锁实现的。想要调用 <code>wait()</code> 和 <code>notify()</code>必须先持有该对象的锁。</p>
</blockquote>
<h3 id="2-Monitor中的三种状态集合"><a href="#2-Monitor中的三种状态集合" class="headerlink" title="2.Monitor中的三种状态集合"></a>2.Monitor中的三种状态集合</h3><ul>
<li><p>Entry Set（入口集合）</p>
<p>当多个线程尝试进入某个 <code>synchronized</code> 方法或代码块时，如果锁（Lock）已经被其他线程占有，这些线程会进入 <strong>Entry Set</strong>。这个集合里面的线程都是等待获取锁的状态，一旦锁释放，JVM 会从 Entry Set 里挑选一个线程（通常没有严格顺序，依赖 JVM 实现）去获取锁。</p>
</li>
<li><p>Owner（锁的持有者）</p>
<p>一旦某个线程成功获取锁，它就成为Owner，可以进入临界区（critical section）执行受 <code>synchronized</code> 保护的代码。</p>
</li>
<li><p>Wait Set（等待集合）</p>
<p>如果线程在执行临界区时调用了 <code>wait()</code>，它会释放锁并进入Wait Set。进入 Wait Set 的线程并不是等待锁，而是等待 其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒它。</p>
</li>
</ul>
<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><p>​	死锁是多线程编程中常见的一种并发问题。它指的是 <strong>多个线程在竞争资源时，互相等待对方释放锁，导致所有线程都无法继续执行</strong> 的情况。比如：线程A拿到了资源1，想要资源2，线程B拿到了资源2，想要资源1，结果就是A和B都在等对方程序就卡住了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deadlock</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Friend</span><span class="params">(String name)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bow</span><span class="params">(Friend bower)</span> &#123;</span><br><span class="line">			System.out.format(<span class="string">&quot;%s: %s&quot;</span> + <span class="string">&quot;  has bowed to me!%n&quot;</span>, <span class="built_in">this</span>.name, bower.getName());</span><br><span class="line">			bower.bowBack(<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bowBack</span><span class="params">(Friend bower)</span> &#123;</span><br><span class="line">			System.out.format(<span class="string">&quot;%s: %s&quot;</span> + <span class="string">&quot; has bowed back to me!%n&quot;</span>, <span class="built_in">this</span>.name, bower.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Friend</span> <span class="variable">alphonse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Friend</span>(<span class="string">&quot;Alphonse&quot;</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Friend</span> <span class="variable">gaston</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Friend</span>(<span class="string">&quot;Gaston&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				alphonse.bow(gaston);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				gaston.bow(alphonse);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像示例代码这样第一个线程先是拿到了alphonse的锁然后需要调用<code>gaston.bowBack(alphonse)</code>，但是此时第二个线程已经拿到了gaston的锁因此线程一卡住了，但是此时alphonse的锁还在线程一手里所以线程二也会卡在 <code>alphonse.bowBack(gaston)</code>这里。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread"><span class="nav-number">1.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B%EF%BC%88thread%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">一、认识线程（thread）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%EF%BC%88process%EF%BC%89%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%88Thread%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.线程（process）与进程（Thread）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.在并发执行过程中的关键概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Thread%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.Thread类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">二、控制线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-sleep"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.sleep()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Yield"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.Yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-interrupt"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.interrupt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E8%B0%83%EF%BC%9Ajoin"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.线程之间的协调：join()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%AD%E5%92%8C%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">三、中断和终止线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-interrupted"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.interrupted()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-isInterrupted"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.isInterrupted()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-isAlive"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.isAlive()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.终止线程的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="nav-number">1.4.</span> <span class="nav-text">四、多线程中的数据安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.volatile关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%94%81%E4%B8%8Esynchronized"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.锁与synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-synchronized"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. synchronized</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%88Monitor%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">五、监视器（Monitor）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-notify-%E5%92%8Cwait"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. notify()和wait()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Monitor%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E9%9B%86%E5%90%88"><span class="nav-number">1.5.2.</span> <span class="nav-text">2.Monitor中的三种状态集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.3.</span> <span class="nav-text">3.死锁</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tyx796</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tyx796</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
